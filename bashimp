#!/usr/bin/env bash
###################
# BASHimp - BASH Script Initializer
#
# @author   RuneImp <runeimp@gmail.com>
# @version  0.5.0
# @license  http://opensource.org/licenses/MIT
###
# Installation
# ------------
# 1. bashimp must be in your path and executable.
# 
###
# ChangeLog:
# ----------
# 2015-06-12	v0.5.0		Beginnings of OPTIONimp AKA BASHimp Beast Mode!
# 2015-06-09	v0.4.0		Now does extensive checking for your prefered editor if one wasn't specified in your bashimp.cfg.
# 2015-06-08	v0.3.0      Added the find command. Added the -f and --find, -i and --interpreter, and -p and --posix switches.
#                           Added the loading of a user configuration file. Updated help.
# 2015-06-07	v0.2.0      Added expunge to the command list
# 2015-06-07	v0.1.0		Initial script creation
# 
###
# ToDo:
# -----
# [ ] Add functionality for extended option parsing
#

BASHIMP_AS_OPTIMP=`basename "$0"`
BASHIMP_AUTHOR=""
BASHIMP_ADMIN_MODE=false
BASHIMP_EDITOR=""
BASHIMP_END_OPTIONS=false
BASHIMP_INIT=""
BASHIMP_INTERPRETER="/usr/bin/env bash"
BASHIMP_LICENSES=""
BASHIMP_KILL=""
BASHIMP_PATH="$HOME/bin"
BASHIMP_VER_NUMBER='0.5.0'
BASHIMP_VER_LABEL="BASHimp v$BASHIMP_VER_NUMBER"

# one, -f, --two: $format required Specify format string
# -t, --three: $template optional Specify template string or path
# --four: $forth bool Specify forth dimension
# five: $five bool Execute five times
# -s, --six: $sexy_time required Value for Sexy Time
# declare -a BASHIMP_OPTARG_NAMES=('format' 'format' 'format' 'template' 'template' 'forth' 'five' 'sexy_time')
# declare -a BASHIMP_OPTARGS_REQUIRED=(true true true false false	false false true true)
# declare -a BASHIMP_OPTARGS_OPTIONAL=(false false false true true false false false false)
# declare -a BASHIMP_OPTION_DOCS=('one, -f, --two' 'Specify format string' '-t, --three' 'Specify template string or path' '--four' 'Specify forth dimension' 'five' 'Execute five times' '-s, --six' 'Value for Sexy Time')
# declare -a BASHIMP_OPTION_NAMES=(one f two  t three four five s six)
# declare -a BASHIMP_OPTION_TYPES=('command' 'short switch' 'long switch' 'short switch' 'long switch' 'long switch' 'command' 'short switch' 'long switch')

if [ "$BASHIMP_AS_OPTIMP" == 'bashimp' ]; then
	BASHIMP_AS_OPTIMP=false
else
	BASHIMP_AS_OPTIMP=true
fi

[ -r "${HOME}/.config/bashimp.cfg" ] && source "${HOME}/.config/bashimp.cfg"

#
# BASHimp Codes
#
BASHIMP_ERRORS=`cat <<BASHIMPOED
$BASHIMP_VER_LABEL

Error Codes:
 1 = No options provided
 2 = Unknown option
 3 = Option missing value argument
 4 = File not found (to delete)
 5 = No text editor found

BASHIMPOED`


#
# BASHimp Help
#
BASHIMP_HELP=`cat <<BASHIMPOED
$BASHIMP_VER_LABEL

bashimp [OPTIONS]

  Commands:
    code                    Display exit codes.
    init SCRIPT_NAME        Initialize the named BASH script.
    kill SCRIPT_NAME        Expunge the named BASH script.
                            Will ask for verification.
    find INTERPRETER_NAME   Display a local path for the specified
                            interpreter name.
    help                    Display this help.

  Options:
    -a, --admin                     Use Admin/Multi-User mode.
    -e, --env INTERPRETER_NAME      Use specified interpreter name after
                                    /usr/bin/env when initializing the script.
    -f, --find INTERPRETER_NAME     Find a local path for the specified
                                    interpreter name and use it when
                                    initializing the script.
    -h, --help                      Display this help.
    -i, --interpreter               Specify the full path for initializing the interpreter.
    -p, --posix                     Find a POSIX compliant interpreter and use it's path when
                                    initializing the script.
    -v, --version                   Print out BASHimp version.
 
BASHIMPOED`

##
# BASHimp Functions
#

bashimp_array_find()
{
	local array=("${!1}")
	local count=${#array[@]}
	local value="$2"
	local i=1
	local item
	if [ -n "$value" ]; then
		# echo "bashimp_array_find() -- \${array[@]}: ${array[@]} -- \$count: $count -- \${value}: '${value}'"
		for item in "${array[@]}"
		do
			# echo "bashimp_array_find() -- \${item}: ${item} -- \$i: $i"
			if [ "$item" == "$value" ]; then
				return $i
			fi
			let "i += 1"
		done
	fi

	return 0
}

bashimp_create_script()
{
	exec 3<&1
	exec > "${BASHIMP_PATH}/${BASHIMP_INIT}"
	echo "#!${BASHIMP_INTERPRETER}"
	echo "###################"
	echo "# ${BASHIMP_INIT} v0.1.0"
	echo "#"
	[ ! -z "${BASHIMP_AUTHOR}" ] && echo "# @author ${BASHIMP_AUTHOR}"
	[ ! -z "${BASHIMP_LICENSES}" ] && echo "# @licenses ${BASHIMP_LICENSES}"
	echo "#"
	echo "#"
	echo
	echo
	exec 1<&3 3<&-
}

bashimp_find_shell()
{
	shopt -s nocasematch

	case "$1" in
		POSIX)
			if [ ! -z "$(which bash)" ]; then
				BASHIMP_INTERPRETER="$(which bash)"
			elif [ ! -z "$(which ksh)" ]; then
				BASHIMP_INTERPRETER="$(which ksh)"
			elif [ ! -z "$(which posh)" ]; then
				BASHIMP_INTERPRETER="$(which posh)"
			elif [ -x '/usr/xpg4/bin/sh' ]; then
				BASHIMP_INTERPRETER='/usr/xpg4/bin/sh'
			elif [ ! -z "$(which dash)" ]; then
				BASHIMP_INTERPRETER="$(which dash)"
			elif [ ! -z "$(which sh)" ]; then
				BASHIMP_INTERPRETER="$(which sh)"
			else
				BASHIMP_INTERPRETER='/bin/sh'
			fi
			;;
		*)
			if [ ! -z "$(which "$1")" ]; then
				BASHIMP_INTERPRETER="$(which "$1")"
			else
				BASHIMP_INTERPRETER='/bin/sh'
			fi
			;;
	esac

	shopt -u nocasematch
}

bashimp_option_arg_type()
{
	if [ "${BASHIMP_OPTARGS_REQUIRED[$1]}" == 'true' ]; then
		echo 'required'
	elif [ "${BASHIMP_OPTARGS_OPTIONAL[$1]}" == 'true' ]; then
		echo 'optional'
	elif [ "${BASHIMP_OPTARGS_REQUIRED[$1]}" == 'false' ] && [ "${BASHIMP_OPTARGS_OPTIONAL[$1]}" == 'false' ]; then
		echo 'boolean'
	else
		echo 'empty'
	fi
}

bashimp_option_check()
{
	# local array=("${!1}")
	local option="$1"
	local optarg="$2"
	option="$(echo -e "${option}" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//')"
	bashimp_array_find BASHIMP_OPTION_NAMES[@] "$option"
	index=$?
	if [ $index -gt 0 ]; then
		let "index -= 1"
	else
		echo "Unknown option: '$option'"
		exit 2
	fi

	arg_type=$(bashimp_option_arg_type $index)
	case "$arg_type" in
	required)
		opt_type=$(bashimp_option_type "$optarg")
		if [ "${opt_type}" == 'NON_SWITCH' ]; then
			echo eval ${BASHIMP_OPTARG_NAMES[$index]}'="'${optarg}'"'
		else
			echo "Option argument for \$${BASHIMP_OPTARG_NAMES[$index]} is required" 1>&2
			exit 3
		fi
		;;
	optional)
		opt_type=$(bashimp_option_type "$optarg")
		if [ "${opt_type}" == 'NON_SWITCH' ]; then
			echo eval ${BASHIMP_OPTARG_NAMES[$index]}'="'${optarg}'"'
		else
			echo eval ${BASHIMP_OPTARG_NAMES[$index]}'=true'
		fi
		;;
	boolean)
		echo eval "${BASHIMP_OPTARG_NAMES[$index]}=true"
		;;
	*)
		echo "Unknown argument type: ${arg_type}"
		;;
	esac

	echo "Found ${BASHIMP_OPTION_TYPES[$index]} match for \$${BASHIMP_OPTARG_NAMES[$index]} (${arg_type}) [${index}]"
}

bashimp_option_type()
{
	local tmp="$1"
	if [ -n "$tmp" ]; then
		case "${tmp:0:1}" in
		-)
			if [ "${tmp:0:2}" == '--' ]; then
				if [ ${#tmp} -eq 2 ]; then
					echo 'END_OF_OPTIONS'
				else
					echo 'LONG_SWITCH'
				fi
			else
				if [ ${#tmp} -eq 1 ]; then
					echo 'STD_INPUT'
				else
					echo 'SHORT_SWITCH'
				fi
			fi
			;;
		*)
			echo 'NON_SWITCH'
			;;
		esac
	else
		echo 'EMPTY_NULL'
	fi
}

bashimp_option_required()
{
	# echo "bashimp_option_required() $1"
	if [ $1 -lt 2 ]; then
		echo "echo '  Missing value argument' 1>&2 && exit 3"
	else
		echo "shift 2"
	fi
}

bashimp_shift_break()
{
	# echo "bashimp_shift_break() $1"
	if [ $1 -gt 1 ]; then
		echo shift
	else
		echo break
	fi
}

bashimp_show_codes()
{
	cat <<- _CAT_
	$BASHIMP_ERRORS
	_CAT_
}

bashimp_show_help()
{
	cat <<- _CAT_
	$BASHIMP_HELP
	_CAT_
}


if [ $# -eq 0 ]; then
	bashimp_show_help
	exit 1
fi

if [ $BASHIMP_AS_OPTIMP == true ]; then
	echo "OPTIONimp Loop"
	until [ -z "$1" ]
	do
		case "$1" in
			-h | --help)
				bashimp_show_help
				exit 0
				;;
			-v | --version)
				echo $BASHIMP_VER_LABEL
				exit 0
				;;
			--) # End of options
				BASHIMP_END_OPTIONS=true
				shift
				break
				;;
			--*)
				switch_name="${1:2}"
				bashimp_option_check "${switch_name}" "$2"

				shift
				;;
			-*)
				switch_name="${1:1}"
				if [ ${#switch_name} -gt 1 ]; then
					len=${#switch_name}
					declare -a switch_list
					for ((i=0; i < $len; i++))
					do
						switch_list[$i]="${switch_name:$i:1}"
						bashimp_option_check "${switch_name:$i:1}" "$2"
					done
				else
					bashimp_option_check "${switch_name}" "$2"
				fi

				shift
				;;
			*)
				bashimp_option_check "$1" "$2"

				shift
				# echo "Unknown option: $1" 1>&2
				# exit 2
				;;
		esac
	done
else
	# echo 'BASHimp Loop'

	old_case=$(shopt nocasematch)
	shopt -s nocasematch

	until [ -z "$1" ]
	do
		case "$1" in
			codes | errors | code)
				bashimp_show_codes
				exit 0
				;;
			create | add | init)
				BASHIMP_INIT="$2"
				eval "$(bashimp_option_required $#)"
				;;
			delete | rem | kill | expunge)
				BASHIMP_KILL="$2"
				eval "$(bashimp_option_required $#)"
				;;
			find)
				bashimp_find_shell $2
				echo "${BASHIMP_INTERPRETER}"
				eval "$(bashimp_option_required $#)"
				;;
			-a | --admin) # Admin Mode. Setup script for all users
				BASHIMP_ADMIN_MODE=true
				eval "$(bashimp_shift_break $#)"
				;;
			-e | --env)
				BASHIMP_INTERPRETER="/usr/bin/env $2"
				eval "$(bashimp_option_required $#)"
				;;
			-f | --find)
				bashimp_find_shell $2
				eval "$(bashimp_option_required $#)"
				;;
			help | -h | --help)
				bashimp_show_help
				exit 0
				;;
			-i | --interpreter)
				BASHIMP_INTERPRETER="$2"
				eval "$(bashimp_option_required $#)"
				;;
			-p | --posix)
				bashimp_find_shell 'POSIX'
				eval "$(bashimp_shift_break $#)"
				;;
			-v | --version)
				echo $BASHIMP_VER_LABEL
				exit 0
				;;
			--) # End of options
				shift
				break
				;;
			*)
				echo "Unknown option: $1" 1>&2
				exit 2
				;;
		esac
	done

	if [[ "$old_case" =~ nocasematch.+off ]]; then
		shopt -u nocasematch
	fi
fi

#
# Do some work
#
if [ ! -z "$BASHIMP_INIT" ]; then

	# Update Init Path if in Admin/Multi-User Mode
	if [ $BASHIMP_ADMIN_MODE == true ]; then
		if [ -d '/usr/local/bin' ]; then
			BASHIMP_PATH='/usr/local/bin' # The standard for multi-user scripts, no?
		elif [ -d '/usr/local/opt' ]; then
			BASHIMP_PATH='/usr/local/opt' # @see http://www.extellisys.com/articles/usr-local-opt
		elif [ -d '/opt/bin' ]; then
			BASHIMP_PATH='/opt/bin'       # I've seen this used somewhere...
		else
			BASHIMP_PATH='/usr/local/bin' # Create this if nothing else exists
		fi
	fi

	# Create bin directory if it doesn't already exist
	if [ ! -d "$BASHIMP_PATH" ]; then
		mkdir -p "$BASHIMP_PATH"
	fi

	# Create script or ask if it already exists
	if [ ! -f "${BASHIMP_PATH}/$BASHIMP_INIT" ]; then
		bashimp_create_script
	else
		
		printf "  The file $BASHIMP_INIT already exists. Do you wish to continue? [yes/NO] (n) "
		overwrite='no'
		read overwrite
		case "$overwrite" in
		[Yy] | [Yy][Ee][Ss])
			echo "Overwriting $BASHIMP_INIT"
			bashimp_create_script
			;;
		*)
			echo "Another time maybe..."
			exit 0
			;;
		esac
	fi

	# Fix permissions if not already executable
	if [ -f "${BASHIMP_PATH}/$BASHIMP_INIT" ] && [ ! -x "${BASHIMP_PATH}/$BASHIMP_INIT" ]; then
		chmod u+x "${BASHIMP_PATH}/$BASHIMP_INIT"
	fi

	# Choose script in editor if none defined
	if [ -z "${BASHIMP_EDITOR}" ]; then
		if [ ! -z "$VISUAL" ]; then
			BASHIMP_EDITOR="$VISUAL"
		elif [ ! -z "$GIT_EDITOR" ]; then
			BASHIMP_EDITOR="$GIT_EDITOR"
		elif [ ! -z "$EDITOR" ]; then
			BASHIMP_EDITOR="$EDITOR"
		elif [ ! -z "`which subl`" ]; then
			BASHIMP_EDITOR=`which subl`
		else
			BASHIMP_EDITOR=`which vi`
		fi
	fi

	# Launch script in editor
	if [ ! -z "${BASHIMP_EDITOR}" ]; then
		"${BASHIMP_EDITOR}" "${BASHIMP_PATH}/${BASHIMP_INIT}"
	else
		echo "No BASHIMP_EDITOR defined or found." 1>&2
		exit 5
	fi

elif [ ! -z "$BASHIMP_KILL" ]; then

	# Update Init Path if in Admin/Multi-User Mode
	if [ $BASHIMP_ADMIN_MODE == true ]; then
		if [ -d '/usr/local/bin' ]; then
			BASHIMP_PATH='/usr/local/bin' # The standard for multi-user scripts, no?
		elif [ -d '/usr/local/opt' ]; then
			BASHIMP_PATH='/usr/local/opt' # @see http://www.extellisys.com/articles/usr-local-opt
		elif [ -d '/opt/bin' ]; then
			BASHIMP_PATH='/opt/bin'       # I've seen this used somewhere...
		else
			BASHIMP_PATH='/usr/local/bin' # Create this if nothing else exists
		fi
	fi

	# Expunge script
	if [ -f "${BASHIMP_PATH}/${BASHIMP_KILL}" ]; then
		printf "  Are you sure you want to expunge $BASHIMP_KILL from this computer [yes/NO] (n) "
		read expunge
		case "$expunge" in
		[Yy] | [Yy][Ee][Ss])
			echo "Expunging ${BASHIMP_PATH}/${BASHIMP_KILL}"
			rm "${BASHIMP_PATH}/${BASHIMP_KILL}"
			;;
		*)
			echo "Another time maybe..."
			exit 0
			;;
		esac
	else
		echo "File not found"
		echo "Expected to find the script at ${BASHIMP_PATH}/${BASHIMP_KILL}"
		exit 4
	fi

fi

exit 0
